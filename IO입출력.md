
## I/O 입출력

### 입출력이 무엇인가
* A 프로그램에서 B 프로그램으로 데이터를 주고 받는 경우 입력(Input)과 출력(Output)이 반복적으로 일어난다. 
* 사용자가 프로그램을 통해 키보드/마우스/파일 입력(Input)과 모니터/파일 출력(Output)이 가능하다.
* 즉, 프로그램을 통해 데이터를 주고 받을 경우 입출력이 일어난다고 말할 수 있다.

### 자바(Java) 프로그램에서의 입출력이 무엇인가?
* 위에서 정의한 입출력에서 자바프로그램을 통해 입출력을 하는 경우를 의미한다.
* 자바는 사용자/프로그램 간의 입출력을 하기 위해 다양한 Class를 정의되어있고 이를 이용하여 I/O 입출력이 가능하다.
* 자바에서는 입출력이 가능하게 해주는 통로를 Stream(스트림)으로 정의함.

### 입출력(I/O) 스트림(Stream)
* 입출력으로 데이터를 주고받기 위해서는 Stream을 생성해야 한다.
* Stream은 무조건 단방향이기 때문에 데이터를 주고 받기 위해서는 입력/출력 Stream을 각각 생성하여 사용하여야 한다.


## 2. 멀티쓰레딩
### 1. 멀티쓰레딩의 장점
* CPU 사용률 향상
* 자원의 효율적 사용
* 사용자 응답성 향상
* 작업이 분리되어 코드가 간결해짐

### 2. 멀티쓰레딩의 단점
* 여러 쓰레드가 동일 프로세스에서 작업하기 때문에 동기화 문제 
* 교착상태 문제
* 컨텍스트 스위칭으로 인한 효율 저하

## 3. 간단한 쓰레드 사용 방법
### 1. 쓰레드의 구현과 실행
* Runnable 인터페이스 구현
```
/* 선언방법 */

Class MyThread implements Runnable {
	public void run() {
		/* 작업내용
		 * runnable 인터페이스에 추상메서드 run()을 구현
		 */
	}
}


/* 생성 방법 */

Runnable r = new MyThread();
Thread t2 = new Thread(r);


/* 사용 방법 */
t2.start();
```

* Thread 클래스 상속
```
/* 선언 방법 */
class MyThread extends Thread {
	public void run() {
		/* 작업내용
		 * Thread 클래스의 run() 오버라이딩 
		 */
	}
}

/* 생성 방법 */

Thread t1 = new MyThread();


/* 사용 방법 */
t1.start();
```

### 2. 차이점
* Thread는 상속을 받으며 Runnable은 인터페이스로서 구현한다
* Thread는 재사용이 불가능하며 Runnable은 가능하다
* Thread 사용시 다른 클래스를 상속받을 수 없다 

### 3.  start() 와 run()
* run() 메소드를 호출한다면 클래스에 선언된 메소드만 호출하는 것
* start()는 새로운 쓰레드가 작업하는데 필요한 호출 스택을 생성
* 호출 스택을 생성한 다음 가장 먼저 run() 메서드를 호출스택에 올림
* main 메서드의 모든 작업도 main 쓰레드에서 동작
* 실행중인 ‘사용자 쓰레드’가 하나도 없을 때  프로그램은 종료 된다.

## 4. 쓰레드 동기화
* 멀티쓰레드 작업일 경우 여러 쓰레드가 프로세스 내의 자원을 공유
* 공유자원 상태에 영향을 끼칠 수 있음
* 특정 작업을 끝마치기 전까지 다른 쓰레드로 부터 방해받지 않는 방법이 필요
* 임계영역 (critical section)
* 락 (lock)
 
### 1. synchronized
* 임계영역을 지정하는데 사용
```
/* 1. 메소드 전체를 임계영역으로 설정 */ 
public synchronized void calcSum() {
	/* 임계 영역 */
}


/* 2. 특정한 영역을 임계 영역으로 지정
synchronized (객체의 참조변수) {
	/* 임계 영역 */
}

// 객체의 참조변수란 락을 걸고자 하는 객체를 참조하는 것
// 보통 해당 임계영역을 호출한 객체를 표현 -> 주로 this
// 동기화 블럭안에 전달된 객체를 모니터 객체라고 부름
```

### 2. wait() , notify()
* synchronized로 동기화된 임계영역을 상주하는 쓰레드 문제 
* 락을 가진 상태로 오랜 시간을 보내는것은 자원 낭비
* 동기화된 임계영역에서 코드 수행이 어려울 경우 wait() 호출을 통해 대기상태로 진입
* 작업을 진행 할 수 있는 상황이 되면 notify() 를 호출하여 작업을 중단했던 스레드가 다시 락을 얻어 작업을 진행할 수 있게 함
* notify() 같은 경우 원하는 쓰레드에 전달이 안될 수도 있기 때문에 notifyAll()을 호출함
* 기아현상 발생 가능
	* 대기상태로 들어간 쓰레드가 notify() 통지를 받지 못하고 계속해서 기다리는 현상
	* notifyAll()을 사용해 모든 쓰레드에게 통지하여 기아 상태를 해결
	* 모든 쓰레드가 notify() 받기 때문에 필요없는 쓰레드들이 lock을 얻기위해 경쟁함
	* 이를 경쟁상태라 부름

### 3. volatile
* 코어 <-> cache <-> memory 사이에서 일어나는 문제에서 사용
* 메모리에 저장된 변수값과 캐시에 저장된 변수 값이 달라 문제 발생
```
boolean suspended = false;
->
volatile boolean suspended = false;
```

* synchronized 블럭도 캐시와 메모리 사이 동기화가 이루어짐
* volatile 를 활용하여 명령을 원자화 시킴
* 명령을 원자화 하는것과 동기화를 하는것은 아님

### 4. For & join 프레임워크

## 5. Spring의 쓰레드
### 1.ThreadPoolTaskExecutor
### 2.@Async

## 6. Java 8의 쓰레드
